// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/DeluxeOwl/kala-go/ent/permission"
	"github.com/DeluxeOwl/kala-go/ent/predicate"
	"github.com/DeluxeOwl/kala-go/ent/relation"
	"github.com/DeluxeOwl/kala-go/ent/subject"
	"github.com/DeluxeOwl/kala-go/ent/tuple"
	"github.com/DeluxeOwl/kala-go/ent/typeconfig"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypePermission = "Permission"
	TypeRelation   = "Relation"
	TypeSubject    = "Subject"
	TypeTuple      = "Tuple"
	TypeTypeConfig = "TypeConfig"
)

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	value             *string
	clearedFields     map[string]struct{}
	typeconfig        *int
	clearedtypeconfig bool
	relations         map[int]struct{}
	removedrelations  map[int]struct{}
	clearedrelations  bool
	done              bool
	oldValue          func(context.Context) (*Permission, error)
	predicates        []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *PermissionMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *PermissionMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *PermissionMutation) ResetValue() {
	m.value = nil
}

// SetTypeconfigID sets the "typeconfig" edge to the TypeConfig entity by id.
func (m *PermissionMutation) SetTypeconfigID(id int) {
	m.typeconfig = &id
}

// ClearTypeconfig clears the "typeconfig" edge to the TypeConfig entity.
func (m *PermissionMutation) ClearTypeconfig() {
	m.clearedtypeconfig = true
}

// TypeconfigCleared reports if the "typeconfig" edge to the TypeConfig entity was cleared.
func (m *PermissionMutation) TypeconfigCleared() bool {
	return m.clearedtypeconfig
}

// TypeconfigID returns the "typeconfig" edge ID in the mutation.
func (m *PermissionMutation) TypeconfigID() (id int, exists bool) {
	if m.typeconfig != nil {
		return *m.typeconfig, true
	}
	return
}

// TypeconfigIDs returns the "typeconfig" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeconfigID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) TypeconfigIDs() (ids []int) {
	if id := m.typeconfig; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypeconfig resets all changes to the "typeconfig" edge.
func (m *PermissionMutation) ResetTypeconfig() {
	m.typeconfig = nil
	m.clearedtypeconfig = false
}

// AddRelationIDs adds the "relations" edge to the Relation entity by ids.
func (m *PermissionMutation) AddRelationIDs(ids ...int) {
	if m.relations == nil {
		m.relations = make(map[int]struct{})
	}
	for i := range ids {
		m.relations[ids[i]] = struct{}{}
	}
}

// ClearRelations clears the "relations" edge to the Relation entity.
func (m *PermissionMutation) ClearRelations() {
	m.clearedrelations = true
}

// RelationsCleared reports if the "relations" edge to the Relation entity was cleared.
func (m *PermissionMutation) RelationsCleared() bool {
	return m.clearedrelations
}

// RemoveRelationIDs removes the "relations" edge to the Relation entity by IDs.
func (m *PermissionMutation) RemoveRelationIDs(ids ...int) {
	if m.removedrelations == nil {
		m.removedrelations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.relations, ids[i])
		m.removedrelations[ids[i]] = struct{}{}
	}
}

// RemovedRelations returns the removed IDs of the "relations" edge to the Relation entity.
func (m *PermissionMutation) RemovedRelationsIDs() (ids []int) {
	for id := range m.removedrelations {
		ids = append(ids, id)
	}
	return
}

// RelationsIDs returns the "relations" edge IDs in the mutation.
func (m *PermissionMutation) RelationsIDs() (ids []int) {
	for id := range m.relations {
		ids = append(ids, id)
	}
	return
}

// ResetRelations resets all changes to the "relations" edge.
func (m *PermissionMutation) ResetRelations() {
	m.relations = nil
	m.clearedrelations = false
	m.removedrelations = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.value != nil {
		fields = append(fields, permission.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldName:
		return m.Name()
	case permission.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.typeconfig != nil {
		edges = append(edges, permission.EdgeTypeconfig)
	}
	if m.relations != nil {
		edges = append(edges, permission.EdgeRelations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeTypeconfig:
		if id := m.typeconfig; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.relations))
		for id := range m.relations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrelations != nil {
		edges = append(edges, permission.EdgeRelations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.removedrelations))
		for id := range m.removedrelations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtypeconfig {
		edges = append(edges, permission.EdgeTypeconfig)
	}
	if m.clearedrelations {
		edges = append(edges, permission.EdgeRelations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeTypeconfig:
		return m.clearedtypeconfig
	case permission.EdgeRelations:
		return m.clearedrelations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeTypeconfig:
		m.ClearTypeconfig()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeTypeconfig:
		m.ResetTypeconfig()
		return nil
	case permission.EdgeRelations:
		m.ResetRelations()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RelationMutation represents an operation that mutates the Relation nodes in the graph.
type RelationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	value                  *string
	clearedFields          map[string]struct{}
	typeconfig             *int
	clearedtypeconfig      bool
	rel_typeconfigs        map[int]struct{}
	removedrel_typeconfigs map[int]struct{}
	clearedrel_typeconfigs bool
	permissions            map[int]struct{}
	removedpermissions     map[int]struct{}
	clearedpermissions     bool
	tuples                 map[int]struct{}
	removedtuples          map[int]struct{}
	clearedtuples          bool
	done                   bool
	oldValue               func(context.Context) (*Relation, error)
	predicates             []predicate.Relation
}

var _ ent.Mutation = (*RelationMutation)(nil)

// relationOption allows management of the mutation configuration using functional options.
type relationOption func(*RelationMutation)

// newRelationMutation creates new mutation for the Relation entity.
func newRelationMutation(c config, op Op, opts ...relationOption) *RelationMutation {
	m := &RelationMutation{
		config:        c,
		op:            op,
		typ:           TypeRelation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRelationID sets the ID field of the mutation.
func withRelationID(id int) relationOption {
	return func(m *RelationMutation) {
		var (
			err   error
			once  sync.Once
			value *Relation
		)
		m.oldValue = func(ctx context.Context) (*Relation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Relation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelation sets the old Relation of the mutation.
func withRelation(node *Relation) relationOption {
	return func(m *RelationMutation) {
		m.oldValue = func(context.Context) (*Relation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RelationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RelationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RelationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RelationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Relation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RelationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RelationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Relation entity.
// If the Relation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RelationMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *RelationMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RelationMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Relation entity.
// If the Relation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RelationMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RelationMutation) ResetValue() {
	m.value = nil
}

// SetTypeconfigID sets the "typeconfig" edge to the TypeConfig entity by id.
func (m *RelationMutation) SetTypeconfigID(id int) {
	m.typeconfig = &id
}

// ClearTypeconfig clears the "typeconfig" edge to the TypeConfig entity.
func (m *RelationMutation) ClearTypeconfig() {
	m.clearedtypeconfig = true
}

// TypeconfigCleared reports if the "typeconfig" edge to the TypeConfig entity was cleared.
func (m *RelationMutation) TypeconfigCleared() bool {
	return m.clearedtypeconfig
}

// TypeconfigID returns the "typeconfig" edge ID in the mutation.
func (m *RelationMutation) TypeconfigID() (id int, exists bool) {
	if m.typeconfig != nil {
		return *m.typeconfig, true
	}
	return
}

// TypeconfigIDs returns the "typeconfig" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeconfigID instead. It exists only for internal usage by the builders.
func (m *RelationMutation) TypeconfigIDs() (ids []int) {
	if id := m.typeconfig; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypeconfig resets all changes to the "typeconfig" edge.
func (m *RelationMutation) ResetTypeconfig() {
	m.typeconfig = nil
	m.clearedtypeconfig = false
}

// AddRelTypeconfigIDs adds the "rel_typeconfigs" edge to the TypeConfig entity by ids.
func (m *RelationMutation) AddRelTypeconfigIDs(ids ...int) {
	if m.rel_typeconfigs == nil {
		m.rel_typeconfigs = make(map[int]struct{})
	}
	for i := range ids {
		m.rel_typeconfigs[ids[i]] = struct{}{}
	}
}

// ClearRelTypeconfigs clears the "rel_typeconfigs" edge to the TypeConfig entity.
func (m *RelationMutation) ClearRelTypeconfigs() {
	m.clearedrel_typeconfigs = true
}

// RelTypeconfigsCleared reports if the "rel_typeconfigs" edge to the TypeConfig entity was cleared.
func (m *RelationMutation) RelTypeconfigsCleared() bool {
	return m.clearedrel_typeconfigs
}

// RemoveRelTypeconfigIDs removes the "rel_typeconfigs" edge to the TypeConfig entity by IDs.
func (m *RelationMutation) RemoveRelTypeconfigIDs(ids ...int) {
	if m.removedrel_typeconfigs == nil {
		m.removedrel_typeconfigs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.rel_typeconfigs, ids[i])
		m.removedrel_typeconfigs[ids[i]] = struct{}{}
	}
}

// RemovedRelTypeconfigs returns the removed IDs of the "rel_typeconfigs" edge to the TypeConfig entity.
func (m *RelationMutation) RemovedRelTypeconfigsIDs() (ids []int) {
	for id := range m.removedrel_typeconfigs {
		ids = append(ids, id)
	}
	return
}

// RelTypeconfigsIDs returns the "rel_typeconfigs" edge IDs in the mutation.
func (m *RelationMutation) RelTypeconfigsIDs() (ids []int) {
	for id := range m.rel_typeconfigs {
		ids = append(ids, id)
	}
	return
}

// ResetRelTypeconfigs resets all changes to the "rel_typeconfigs" edge.
func (m *RelationMutation) ResetRelTypeconfigs() {
	m.rel_typeconfigs = nil
	m.clearedrel_typeconfigs = false
	m.removedrel_typeconfigs = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RelationMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RelationMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RelationMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RelationMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RelationMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RelationMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RelationMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddTupleIDs adds the "tuples" edge to the Tuple entity by ids.
func (m *RelationMutation) AddTupleIDs(ids ...int) {
	if m.tuples == nil {
		m.tuples = make(map[int]struct{})
	}
	for i := range ids {
		m.tuples[ids[i]] = struct{}{}
	}
}

// ClearTuples clears the "tuples" edge to the Tuple entity.
func (m *RelationMutation) ClearTuples() {
	m.clearedtuples = true
}

// TuplesCleared reports if the "tuples" edge to the Tuple entity was cleared.
func (m *RelationMutation) TuplesCleared() bool {
	return m.clearedtuples
}

// RemoveTupleIDs removes the "tuples" edge to the Tuple entity by IDs.
func (m *RelationMutation) RemoveTupleIDs(ids ...int) {
	if m.removedtuples == nil {
		m.removedtuples = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tuples, ids[i])
		m.removedtuples[ids[i]] = struct{}{}
	}
}

// RemovedTuples returns the removed IDs of the "tuples" edge to the Tuple entity.
func (m *RelationMutation) RemovedTuplesIDs() (ids []int) {
	for id := range m.removedtuples {
		ids = append(ids, id)
	}
	return
}

// TuplesIDs returns the "tuples" edge IDs in the mutation.
func (m *RelationMutation) TuplesIDs() (ids []int) {
	for id := range m.tuples {
		ids = append(ids, id)
	}
	return
}

// ResetTuples resets all changes to the "tuples" edge.
func (m *RelationMutation) ResetTuples() {
	m.tuples = nil
	m.clearedtuples = false
	m.removedtuples = nil
}

// Where appends a list predicates to the RelationMutation builder.
func (m *RelationMutation) Where(ps ...predicate.Relation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RelationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Relation).
func (m *RelationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RelationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, relation.FieldName)
	}
	if m.value != nil {
		fields = append(fields, relation.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RelationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case relation.FieldName:
		return m.Name()
	case relation.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RelationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case relation.FieldName:
		return m.OldName(ctx)
	case relation.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Relation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case relation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case relation.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Relation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RelationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RelationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RelationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Relation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RelationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RelationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RelationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Relation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RelationMutation) ResetField(name string) error {
	switch name {
	case relation.FieldName:
		m.ResetName()
		return nil
	case relation.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Relation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RelationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.typeconfig != nil {
		edges = append(edges, relation.EdgeTypeconfig)
	}
	if m.rel_typeconfigs != nil {
		edges = append(edges, relation.EdgeRelTypeconfigs)
	}
	if m.permissions != nil {
		edges = append(edges, relation.EdgePermissions)
	}
	if m.tuples != nil {
		edges = append(edges, relation.EdgeTuples)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RelationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case relation.EdgeTypeconfig:
		if id := m.typeconfig; id != nil {
			return []ent.Value{*id}
		}
	case relation.EdgeRelTypeconfigs:
		ids := make([]ent.Value, 0, len(m.rel_typeconfigs))
		for id := range m.rel_typeconfigs {
			ids = append(ids, id)
		}
		return ids
	case relation.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case relation.EdgeTuples:
		ids := make([]ent.Value, 0, len(m.tuples))
		for id := range m.tuples {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RelationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrel_typeconfigs != nil {
		edges = append(edges, relation.EdgeRelTypeconfigs)
	}
	if m.removedpermissions != nil {
		edges = append(edges, relation.EdgePermissions)
	}
	if m.removedtuples != nil {
		edges = append(edges, relation.EdgeTuples)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RelationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case relation.EdgeRelTypeconfigs:
		ids := make([]ent.Value, 0, len(m.removedrel_typeconfigs))
		for id := range m.removedrel_typeconfigs {
			ids = append(ids, id)
		}
		return ids
	case relation.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case relation.EdgeTuples:
		ids := make([]ent.Value, 0, len(m.removedtuples))
		for id := range m.removedtuples {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RelationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtypeconfig {
		edges = append(edges, relation.EdgeTypeconfig)
	}
	if m.clearedrel_typeconfigs {
		edges = append(edges, relation.EdgeRelTypeconfigs)
	}
	if m.clearedpermissions {
		edges = append(edges, relation.EdgePermissions)
	}
	if m.clearedtuples {
		edges = append(edges, relation.EdgeTuples)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RelationMutation) EdgeCleared(name string) bool {
	switch name {
	case relation.EdgeTypeconfig:
		return m.clearedtypeconfig
	case relation.EdgeRelTypeconfigs:
		return m.clearedrel_typeconfigs
	case relation.EdgePermissions:
		return m.clearedpermissions
	case relation.EdgeTuples:
		return m.clearedtuples
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RelationMutation) ClearEdge(name string) error {
	switch name {
	case relation.EdgeTypeconfig:
		m.ClearTypeconfig()
		return nil
	}
	return fmt.Errorf("unknown Relation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RelationMutation) ResetEdge(name string) error {
	switch name {
	case relation.EdgeTypeconfig:
		m.ResetTypeconfig()
		return nil
	case relation.EdgeRelTypeconfigs:
		m.ResetRelTypeconfigs()
		return nil
	case relation.EdgePermissions:
		m.ResetPermissions()
		return nil
	case relation.EdgeTuples:
		m.ResetTuples()
		return nil
	}
	return fmt.Errorf("unknown Relation edge %s", name)
}

// SubjectMutation represents an operation that mutates the Subject nodes in the graph.
type SubjectMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	_type         *int
	cleared_type  bool
	done          bool
	oldValue      func(context.Context) (*Subject, error)
	predicates    []predicate.Subject
}

var _ ent.Mutation = (*SubjectMutation)(nil)

// subjectOption allows management of the mutation configuration using functional options.
type subjectOption func(*SubjectMutation)

// newSubjectMutation creates new mutation for the Subject entity.
func newSubjectMutation(c config, op Op, opts ...subjectOption) *SubjectMutation {
	m := &SubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectID sets the ID field of the mutation.
func withSubjectID(id int) subjectOption {
	return func(m *SubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Subject
		)
		m.oldValue = func(ctx context.Context) (*Subject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubject sets the old Subject of the mutation.
func withSubject(node *Subject) subjectOption {
	return func(m *SubjectMutation) {
		m.oldValue = func(context.Context) (*Subject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SubjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Subject entity.
// If the Subject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubjectMutation) ResetName() {
	m.name = nil
}

// SetTypeID sets the "type" edge to the TypeConfig entity by id.
func (m *SubjectMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the "type" edge to the TypeConfig entity.
func (m *SubjectMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared reports if the "type" edge to the TypeConfig entity was cleared.
func (m *SubjectMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the "type" edge ID in the mutation.
func (m *SubjectMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the "type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *SubjectMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType resets all changes to the "type" edge.
func (m *SubjectMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Where appends a list predicates to the SubjectMutation builder.
func (m *SubjectMutation) Where(ps ...predicate.Subject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subject).
func (m *SubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, subject.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subject.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subject.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Subject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subject.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Subject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectMutation) ResetField(name string) error {
	switch name {
	case subject.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Subject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._type != nil {
		edges = append(edges, subject.EdgeType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subject.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_type {
		edges = append(edges, subject.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectMutation) EdgeCleared(name string) bool {
	switch name {
	case subject.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectMutation) ClearEdge(name string) error {
	switch name {
	case subject.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Subject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectMutation) ResetEdge(name string) error {
	switch name {
	case subject.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Subject edge %s", name)
}

// TupleMutation represents an operation that mutates the Tuple nodes in the graph.
type TupleMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clearedFields   map[string]struct{}
	subject         *int
	clearedsubject  bool
	relation        *int
	clearedrelation bool
	resource        *int
	clearedresource bool
	done            bool
	oldValue        func(context.Context) (*Tuple, error)
	predicates      []predicate.Tuple
}

var _ ent.Mutation = (*TupleMutation)(nil)

// tupleOption allows management of the mutation configuration using functional options.
type tupleOption func(*TupleMutation)

// newTupleMutation creates new mutation for the Tuple entity.
func newTupleMutation(c config, op Op, opts ...tupleOption) *TupleMutation {
	m := &TupleMutation{
		config:        c,
		op:            op,
		typ:           TypeTuple,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTupleID sets the ID field of the mutation.
func withTupleID(id int) tupleOption {
	return func(m *TupleMutation) {
		var (
			err   error
			once  sync.Once
			value *Tuple
		)
		m.oldValue = func(ctx context.Context) (*Tuple, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tuple.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTuple sets the old Tuple of the mutation.
func withTuple(node *Tuple) tupleOption {
	return func(m *TupleMutation) {
		m.oldValue = func(context.Context) (*Tuple, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TupleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TupleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TupleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TupleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tuple.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubjectID sets the "subject_id" field.
func (m *TupleMutation) SetSubjectID(i int) {
	m.subject = &i
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *TupleMutation) SubjectID() (r int, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Tuple entity.
// If the Tuple object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TupleMutation) OldSubjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *TupleMutation) ResetSubjectID() {
	m.subject = nil
}

// SetRelationID sets the "relation_id" field.
func (m *TupleMutation) SetRelationID(i int) {
	m.relation = &i
}

// RelationID returns the value of the "relation_id" field in the mutation.
func (m *TupleMutation) RelationID() (r int, exists bool) {
	v := m.relation
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationID returns the old "relation_id" field's value of the Tuple entity.
// If the Tuple object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TupleMutation) OldRelationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationID: %w", err)
	}
	return oldValue.RelationID, nil
}

// ResetRelationID resets all changes to the "relation_id" field.
func (m *TupleMutation) ResetRelationID() {
	m.relation = nil
}

// SetResourceID sets the "resource_id" field.
func (m *TupleMutation) SetResourceID(i int) {
	m.resource = &i
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *TupleMutation) ResourceID() (r int, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Tuple entity.
// If the Tuple object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TupleMutation) OldResourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *TupleMutation) ResetResourceID() {
	m.resource = nil
}

// ClearSubject clears the "subject" edge to the Subject entity.
func (m *TupleMutation) ClearSubject() {
	m.clearedsubject = true
}

// SubjectCleared reports if the "subject" edge to the Subject entity was cleared.
func (m *TupleMutation) SubjectCleared() bool {
	return m.clearedsubject
}

// SubjectIDs returns the "subject" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectID instead. It exists only for internal usage by the builders.
func (m *TupleMutation) SubjectIDs() (ids []int) {
	if id := m.subject; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubject resets all changes to the "subject" edge.
func (m *TupleMutation) ResetSubject() {
	m.subject = nil
	m.clearedsubject = false
}

// ClearRelation clears the "relation" edge to the Relation entity.
func (m *TupleMutation) ClearRelation() {
	m.clearedrelation = true
}

// RelationCleared reports if the "relation" edge to the Relation entity was cleared.
func (m *TupleMutation) RelationCleared() bool {
	return m.clearedrelation
}

// RelationIDs returns the "relation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RelationID instead. It exists only for internal usage by the builders.
func (m *TupleMutation) RelationIDs() (ids []int) {
	if id := m.relation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelation resets all changes to the "relation" edge.
func (m *TupleMutation) ResetRelation() {
	m.relation = nil
	m.clearedrelation = false
}

// ClearResource clears the "resource" edge to the Subject entity.
func (m *TupleMutation) ClearResource() {
	m.clearedresource = true
}

// ResourceCleared reports if the "resource" edge to the Subject entity was cleared.
func (m *TupleMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *TupleMutation) ResourceIDs() (ids []int) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *TupleMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// Where appends a list predicates to the TupleMutation builder.
func (m *TupleMutation) Where(ps ...predicate.Tuple) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TupleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tuple).
func (m *TupleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TupleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.subject != nil {
		fields = append(fields, tuple.FieldSubjectID)
	}
	if m.relation != nil {
		fields = append(fields, tuple.FieldRelationID)
	}
	if m.resource != nil {
		fields = append(fields, tuple.FieldResourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TupleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tuple.FieldSubjectID:
		return m.SubjectID()
	case tuple.FieldRelationID:
		return m.RelationID()
	case tuple.FieldResourceID:
		return m.ResourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TupleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tuple.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case tuple.FieldRelationID:
		return m.OldRelationID(ctx)
	case tuple.FieldResourceID:
		return m.OldResourceID(ctx)
	}
	return nil, fmt.Errorf("unknown Tuple field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TupleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tuple.FieldSubjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case tuple.FieldRelationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationID(v)
		return nil
	case tuple.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	}
	return fmt.Errorf("unknown Tuple field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TupleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TupleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TupleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tuple numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TupleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TupleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TupleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tuple nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TupleMutation) ResetField(name string) error {
	switch name {
	case tuple.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case tuple.FieldRelationID:
		m.ResetRelationID()
		return nil
	case tuple.FieldResourceID:
		m.ResetResourceID()
		return nil
	}
	return fmt.Errorf("unknown Tuple field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TupleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.subject != nil {
		edges = append(edges, tuple.EdgeSubject)
	}
	if m.relation != nil {
		edges = append(edges, tuple.EdgeRelation)
	}
	if m.resource != nil {
		edges = append(edges, tuple.EdgeResource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TupleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tuple.EdgeSubject:
		if id := m.subject; id != nil {
			return []ent.Value{*id}
		}
	case tuple.EdgeRelation:
		if id := m.relation; id != nil {
			return []ent.Value{*id}
		}
	case tuple.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TupleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TupleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TupleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsubject {
		edges = append(edges, tuple.EdgeSubject)
	}
	if m.clearedrelation {
		edges = append(edges, tuple.EdgeRelation)
	}
	if m.clearedresource {
		edges = append(edges, tuple.EdgeResource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TupleMutation) EdgeCleared(name string) bool {
	switch name {
	case tuple.EdgeSubject:
		return m.clearedsubject
	case tuple.EdgeRelation:
		return m.clearedrelation
	case tuple.EdgeResource:
		return m.clearedresource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TupleMutation) ClearEdge(name string) error {
	switch name {
	case tuple.EdgeSubject:
		m.ClearSubject()
		return nil
	case tuple.EdgeRelation:
		m.ClearRelation()
		return nil
	case tuple.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Tuple unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TupleMutation) ResetEdge(name string) error {
	switch name {
	case tuple.EdgeSubject:
		m.ResetSubject()
		return nil
	case tuple.EdgeRelation:
		m.ResetRelation()
		return nil
	case tuple.EdgeResource:
		m.ResetResource()
		return nil
	}
	return fmt.Errorf("unknown Tuple edge %s", name)
}

// TypeConfigMutation represents an operation that mutates the TypeConfig nodes in the graph.
type TypeConfigMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	clearedFields      map[string]struct{}
	relations          map[int]struct{}
	removedrelations   map[int]struct{}
	clearedrelations   bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	subjects           map[int]struct{}
	removedsubjects    map[int]struct{}
	clearedsubjects    bool
	done               bool
	oldValue           func(context.Context) (*TypeConfig, error)
	predicates         []predicate.TypeConfig
}

var _ ent.Mutation = (*TypeConfigMutation)(nil)

// typeconfigOption allows management of the mutation configuration using functional options.
type typeconfigOption func(*TypeConfigMutation)

// newTypeConfigMutation creates new mutation for the TypeConfig entity.
func newTypeConfigMutation(c config, op Op, opts ...typeconfigOption) *TypeConfigMutation {
	m := &TypeConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeConfigID sets the ID field of the mutation.
func withTypeConfigID(id int) typeconfigOption {
	return func(m *TypeConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeConfig
		)
		m.oldValue = func(ctx context.Context) (*TypeConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeConfig sets the old TypeConfig of the mutation.
func withTypeConfig(node *TypeConfig) typeconfigOption {
	return func(m *TypeConfigMutation) {
		m.oldValue = func(context.Context) (*TypeConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TypeConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TypeConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TypeConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TypeConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TypeConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TypeConfig entity.
// If the TypeConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TypeConfigMutation) ResetName() {
	m.name = nil
}

// AddRelationIDs adds the "relations" edge to the Relation entity by ids.
func (m *TypeConfigMutation) AddRelationIDs(ids ...int) {
	if m.relations == nil {
		m.relations = make(map[int]struct{})
	}
	for i := range ids {
		m.relations[ids[i]] = struct{}{}
	}
}

// ClearRelations clears the "relations" edge to the Relation entity.
func (m *TypeConfigMutation) ClearRelations() {
	m.clearedrelations = true
}

// RelationsCleared reports if the "relations" edge to the Relation entity was cleared.
func (m *TypeConfigMutation) RelationsCleared() bool {
	return m.clearedrelations
}

// RemoveRelationIDs removes the "relations" edge to the Relation entity by IDs.
func (m *TypeConfigMutation) RemoveRelationIDs(ids ...int) {
	if m.removedrelations == nil {
		m.removedrelations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.relations, ids[i])
		m.removedrelations[ids[i]] = struct{}{}
	}
}

// RemovedRelations returns the removed IDs of the "relations" edge to the Relation entity.
func (m *TypeConfigMutation) RemovedRelationsIDs() (ids []int) {
	for id := range m.removedrelations {
		ids = append(ids, id)
	}
	return
}

// RelationsIDs returns the "relations" edge IDs in the mutation.
func (m *TypeConfigMutation) RelationsIDs() (ids []int) {
	for id := range m.relations {
		ids = append(ids, id)
	}
	return
}

// ResetRelations resets all changes to the "relations" edge.
func (m *TypeConfigMutation) ResetRelations() {
	m.relations = nil
	m.clearedrelations = false
	m.removedrelations = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *TypeConfigMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *TypeConfigMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *TypeConfigMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *TypeConfigMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *TypeConfigMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *TypeConfigMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *TypeConfigMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddSubjectIDs adds the "subjects" edge to the Subject entity by ids.
func (m *TypeConfigMutation) AddSubjectIDs(ids ...int) {
	if m.subjects == nil {
		m.subjects = make(map[int]struct{})
	}
	for i := range ids {
		m.subjects[ids[i]] = struct{}{}
	}
}

// ClearSubjects clears the "subjects" edge to the Subject entity.
func (m *TypeConfigMutation) ClearSubjects() {
	m.clearedsubjects = true
}

// SubjectsCleared reports if the "subjects" edge to the Subject entity was cleared.
func (m *TypeConfigMutation) SubjectsCleared() bool {
	return m.clearedsubjects
}

// RemoveSubjectIDs removes the "subjects" edge to the Subject entity by IDs.
func (m *TypeConfigMutation) RemoveSubjectIDs(ids ...int) {
	if m.removedsubjects == nil {
		m.removedsubjects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.subjects, ids[i])
		m.removedsubjects[ids[i]] = struct{}{}
	}
}

// RemovedSubjects returns the removed IDs of the "subjects" edge to the Subject entity.
func (m *TypeConfigMutation) RemovedSubjectsIDs() (ids []int) {
	for id := range m.removedsubjects {
		ids = append(ids, id)
	}
	return
}

// SubjectsIDs returns the "subjects" edge IDs in the mutation.
func (m *TypeConfigMutation) SubjectsIDs() (ids []int) {
	for id := range m.subjects {
		ids = append(ids, id)
	}
	return
}

// ResetSubjects resets all changes to the "subjects" edge.
func (m *TypeConfigMutation) ResetSubjects() {
	m.subjects = nil
	m.clearedsubjects = false
	m.removedsubjects = nil
}

// Where appends a list predicates to the TypeConfigMutation builder.
func (m *TypeConfigMutation) Where(ps ...predicate.TypeConfig) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TypeConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TypeConfig).
func (m *TypeConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TypeConfigMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, typeconfig.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TypeConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typeconfig.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TypeConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typeconfig.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TypeConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typeconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TypeConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TypeConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TypeConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TypeConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TypeConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TypeConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TypeConfigMutation) ResetField(name string) error {
	switch name {
	case typeconfig.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TypeConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TypeConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.relations != nil {
		edges = append(edges, typeconfig.EdgeRelations)
	}
	if m.permissions != nil {
		edges = append(edges, typeconfig.EdgePermissions)
	}
	if m.subjects != nil {
		edges = append(edges, typeconfig.EdgeSubjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TypeConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typeconfig.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.relations))
		for id := range m.relations {
			ids = append(ids, id)
		}
		return ids
	case typeconfig.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case typeconfig.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.subjects))
		for id := range m.subjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TypeConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrelations != nil {
		edges = append(edges, typeconfig.EdgeRelations)
	}
	if m.removedpermissions != nil {
		edges = append(edges, typeconfig.EdgePermissions)
	}
	if m.removedsubjects != nil {
		edges = append(edges, typeconfig.EdgeSubjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TypeConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typeconfig.EdgeRelations:
		ids := make([]ent.Value, 0, len(m.removedrelations))
		for id := range m.removedrelations {
			ids = append(ids, id)
		}
		return ids
	case typeconfig.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case typeconfig.EdgeSubjects:
		ids := make([]ent.Value, 0, len(m.removedsubjects))
		for id := range m.removedsubjects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TypeConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrelations {
		edges = append(edges, typeconfig.EdgeRelations)
	}
	if m.clearedpermissions {
		edges = append(edges, typeconfig.EdgePermissions)
	}
	if m.clearedsubjects {
		edges = append(edges, typeconfig.EdgeSubjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TypeConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case typeconfig.EdgeRelations:
		return m.clearedrelations
	case typeconfig.EdgePermissions:
		return m.clearedpermissions
	case typeconfig.EdgeSubjects:
		return m.clearedsubjects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TypeConfigMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TypeConfigMutation) ResetEdge(name string) error {
	switch name {
	case typeconfig.EdgeRelations:
		m.ResetRelations()
		return nil
	case typeconfig.EdgePermissions:
		m.ResetPermissions()
		return nil
	case typeconfig.EdgeSubjects:
		m.ResetSubjects()
		return nil
	}
	return fmt.Errorf("unknown TypeConfig edge %s", name)
}
